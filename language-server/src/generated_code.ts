import { assert } from 'console';
import * as scriptfiles from './as_parser';
import { getAccPrefix } from './as_parser';
import * as typedb from './database';
import { DBAllowSymbol } from './database';

export function ProcessScriptTypeGeneratedCode(dbtype : typedb.DBType, asmodule : scriptfiles.ASModule)
{
    // // Code that all delegate structs have
    // if (dbtype.isEvent || dbtype.isDelegate)
    //     AddGeneratedCodeForDelegate(dbtype, asmodule);

    if (!dbtype.isStruct && !dbtype.isEnum)
    {
        let decl = new typedb.DBNamespaceDeclaration;
        decl.declaredModule = dbtype.declaredModule;
        decl.declaredOffset = dbtype.moduleOffset;
        decl.declaredOffsetEnd = dbtype.moduleOffsetEnd;
        decl.scopeOffsetStart = dbtype.moduleScopeStart;
        decl.scopeOffsetEnd = dbtype.moduleScopeEnd;

        let nsType = typedb.DeclareNamespace(dbtype.namespace, dbtype.name, decl);

        AddGeneratedCodeForClass(asmodule, dbtype, nsType);

        // // Code that all UObject classes have
        // AddGeneratedCodeForUObject(asmodule, dbtype, nsType);

        // // Code that only actor components have
        // if (dbtype.inheritsFrom("UActorComponent"))
        //     AddGeneratedCodeForUActorComponent(asmodule, dbtype, nsType);

        // // Code that only actors have
        // if (dbtype.inheritsFrom("AActor"))
        //     AddGeneratedCodeForAActor(asmodule, dbtype, nsType);

        // // Code that only subsystems have
        // if (dbtype.inheritsFrom("USubsystem"))
        //     AddGeneratedCodeForSubsystem(asmodule, dbtype, nsType);

        // // Hazelight-specific generated code only if it's configured on
        // if (scriptfiles.GetScriptSettings().useAngelscriptHaze)
        //     AddHazeGeneratedCode(asmodule, dbtype, nsType);

        // Merge namespace into the type database
        asmodule.namespaces.push(nsType);
    }
}

function AddGlobalFunction(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, namespace : typedb.DBNamespace, name : string) : typedb.DBMethod
{
    let method = new typedb.DBMethod();
    method.name = name;
    method.declaredModule = dbtype.declaredModule;
    method.moduleOffset = dbtype.moduleOffset;
    method.isAutoGenerated = true;

    namespace.addSymbol(method);
    asmodule.globalSymbols.push(method);
    return method;
}

function AddMethod(dbtype : typedb.DBType, name : string) : typedb.DBMethod
{
    let method = new typedb.DBMethod();
    method.name = name;
    method.declaredModule = dbtype.declaredModule;
    method.moduleOffset = dbtype.moduleOffset;
    method.isAutoGenerated = true;
    dbtype.addSymbol(method);
    return method;
}

function AddProperty(dbtype : typedb.DBType, name : string) : typedb.DBProperty
{
    let prop = new typedb.DBProperty();
    prop.name = name;
    prop.declaredModule = dbtype.declaredModule;
    prop.moduleOffset = dbtype.moduleOffset;
    prop.isAutoGenerated = true;
    dbtype.addSymbol(prop);
    return prop;
}

function AddGeneratedCodeForClass(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, nsType : typedb.DBNamespace)
{
    {
        console.log(`AddGeneratedCodeForClass: ${dbtype.name} : ${dbtype.supertype}`);
        if (dbtype.supertype) {
            // todo: clearing old `super` functions doesn't seem to work.
            // clear old super definitions
            // dbtype.findSymbols("super").forEach(s => { if (s) dbtype.removeSymbol(s); });
            dbtype.symbols.delete("super");
            // dbtype.symbolsByPrefix.delete // todo, needs an impl
            // get the supertype so we can get the function signature(s)
            let sty = typedb.LookupType(null, dbtype.supertype);
            let supers: typedb.DBMethod[] = [];
            if (sty) {
                let superCons = [
                    ...sty.namespace.findSymbols(typedb.StripNamespaceFromTypeName(dbtype.supertype), DBAllowSymbol.Functions),
                    // ...sty.namespace.findSymbols(dbtype.supertype, DBAllowSymbol.Functions)
                    ];
                for (let superCon of superCons) {
                    if (superCon instanceof typedb.DBMethod) {
                        supers.push(superCon);
                    }
                }
            }
            if (supers.length == 0) {
                supers.push({args: []} as typedb.DBMethod);
            }
            for (let superCon of supers) {
                let method = AddGlobalFunction(asmodule, dbtype, nsType, "super");
                method.returnType = "void";
                method.documentation = `Call constructor of parent class: ${dbtype.supertype}`;
                method.args = superCon.args;
                dbtype.addSymbol(method);
            }
        }
    }
}

// function AddGeneratedCodeForUObject(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, nsType : typedb.DBNamespace)
// {
//     {
//         let method = AddGlobalFunction(asmodule, dbtype, nsType, "StaticClass");
//         method.returnType = "UClass";
//         method.documentation = "Gets the descriptor for the class generated for the specified type.";
//         method.args = [];
//     }
// }

// function AddGeneratedCodeForUActorComponent(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, nsType : typedb.DBNamespace)
// {
//     {
//         let method = AddGlobalFunction(asmodule, dbtype, nsType, getAccPrefix);
//         method.returnType = dbtype.name;
//         method.documentation = "Get the component of this type from an actor. Specified name is optional.";
//         method.args = [
//             new typedb.DBArg().init("AActor", "Actor"),
//             new typedb.DBArg().init("FName", "WithName", "NAME_None"),
//         ];
//     }

//     {
//         let method = AddGlobalFunction(asmodule, dbtype, nsType, "GetOrCreate");
//         method.returnType = dbtype.name;
//         method.documentation = "Get a component of a particular type on an actor, create it if it doesn't exist. Specified name is optional.";
//         method.args = [
//             new typedb.DBArg().init("AActor", "Actor"),
//             new typedb.DBArg().init("FName", "WithName", "NAME_None"),
//         ];
//     }

//     {
//         let method = AddGlobalFunction(asmodule, dbtype, nsType, "Create");
//         method.returnType = dbtype.name;
//         method.documentation = "Always create a new component of this type on an actor.";
//         method.args = [
//             new typedb.DBArg().init("AActor", "Actor"),
//             new typedb.DBArg().init("FName", "WithName", "NAME_None"),
//         ];
//     }
// }

// function AddGeneratedCodeForAActor(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, nsType : typedb.DBNamespace)
// {
//     {
//         let method = AddGlobalFunction(asmodule, dbtype, nsType, "Spawn");
//         method.returnType = dbtype.name;
//         method.documentation = "Spawn a new actor of this type into the world.";
//         method.args = [
//             new typedb.DBArg().init("FVector", "Location", "FVector::ZeroVector"),
//             new typedb.DBArg().init("FRotator", "Rotation", "FRotator::ZeroRotator"),
//             new typedb.DBArg().init("FName", "Name", "NAME_None"),
//             new typedb.DBArg().init("bool", "bDeferredSpawn", "false"),
//             new typedb.DBArg().init("ULevel", "Level", "nullptr"),
//         ];
//     }
// }

function AddGeneratedCodeForSubsystem(asmodule : scriptfiles.ASModule, dbtype : typedb.DBType, nsType : typedb.DBNamespace)
{
    let method = AddGlobalFunction(asmodule, dbtype, nsType, getAccPrefix);
    method.returnType = dbtype.name;
    method.documentation = "Get the relevant "+dbtype.getDisplayName()+" subsystem.";
    method.args = [];
}

function AddGeneratedCodeForDelegate(dbtype : typedb.DBType, asmodule : scriptfiles.ASModule)
{
    {
        let method = AddMethod(dbtype, "IsBound");
        method.returnType = "bool";
        method.documentation = "Whether the anything is bound to the delegate.";
        method.args = [];
    }

    {
        let method = AddMethod(dbtype, "Clear");
        method.returnType = "void";
        method.documentation = "Remove all bindings from the delegate.";
        method.args = [];
    }

    if (dbtype.isEvent)
    {
        {
            let method = AddMethod(dbtype, "Broadcast");
            method.returnType = dbtype.delegateReturn;
            method.documentation = "Broadcast event to all existing bindings.";
            method.args = new Array<typedb.DBArg>();
            for (let delegateArg of dbtype.delegateArgs)
            {
                let arg = new typedb.DBArg();
                arg.name = delegateArg.name;
                arg.typename = delegateArg.typename;
                method.args.push(arg);
            }
        }

        // {
        //     let method = AddMethod(dbtype, "AddUFunction");
        //     method.returnType = "void";
        //     method.documentation = "Add a new binding to this event. Make sure the function you're binding is a UFUNCTION().";
        //     method.isDelegateBindFunction = true;
        //     method.delegateBindType = dbtype.name;
        //     method.delegateObjectParam = 0;
        //     method.delegateFunctionParam = 1;
        //     method.args = [
        //         new typedb.DBArg().init("UObject", "Object"),
        //         new typedb.DBArg().init("FName", "FunctionName"),
        //     ];
        // }

        {
            let method = AddMethod(dbtype, "Unbind");
            method.returnType = "void";
            method.documentation = "Unbind a specific function that was previously added to this event.";
            method.isDelegateBindFunction = true;
            method.delegateBindType = dbtype.name;
            method.delegateObjectParam = 0;
            method.delegateFunctionParam = 1;
            method.args = [
                new typedb.DBArg().init("UObject", "Object"),
                new typedb.DBArg().init("FName", "FunctionName"),
            ];
        }

        {
            let method = AddMethod(dbtype, "UnbindObject");
            method.returnType = "void";
            method.documentation = "Unbind all previously added functions that are called on the specified object.";
            method.args = [
                new typedb.DBArg().init("UObject", "Object"),
            ];
        }
    }
    else
    {
        {
            let method = AddMethod(dbtype, "Execute");
            method.returnType = dbtype.delegateReturn;
            method.documentation = "Execute the function bound to the delegate. Will throw an error if nothing is bound, use ExecuteIfBound() if you do not want an error in that case.";
            method.args = new Array<typedb.DBArg>();
            for (let delegateArg of dbtype.delegateArgs)
            {
                let arg = new typedb.DBArg();
                arg.name = delegateArg.name;
                arg.typename = delegateArg.typename;
                method.args.push(arg);
            }
        }

        {
            let method = AddMethod(dbtype, "ExecuteIfBound");
            method.returnType = dbtype.delegateReturn;
            method.documentation = "Execute the function if one is bound to the delegate, otherwise do nothing.";
            method.args = new Array<typedb.DBArg>();
            for (let delegateArg of dbtype.delegateArgs)
            {
                let arg = new typedb.DBArg();
                arg.name = delegateArg.name;
                arg.typename = delegateArg.typename;
                method.args.push(arg);
            }
        }

        {
            let method = AddMethod(dbtype, "BindUFunction");
            method.returnType = "void";
            method.documentation = "Set the function that is bound to this delegate. Make sure the function you're binding is a UFUNCTION().";
            method.delegateBindType = dbtype.name;
            method.delegateObjectParam = 0;
            method.delegateFunctionParam = 1;
            method.isDelegateBindFunction = true;
            method.args = [
                new typedb.DBArg().init("UObject", "Object"),
                new typedb.DBArg().init("FName", "FunctionName"),
            ];
        }

        {
            let method = AddMethod(dbtype, "GetUObject");
            method.isProperty = true;
            method.name = "GetUObject";
            method.returnType = "UObject";
            method.documentation = "Get the object that this delegate is bound to. Returns nullptr if unbound.";
            method.args = [];
        }

        {
            let method = AddMethod(dbtype, "GetFunctionName");
            method.isProperty = true;
            method.returnType = "FName";
            method.documentation = "Get the function that this delegate is bound to. Returns NAME_None if unbound.";
            method.args = [];
        }

        {
            let method = AddGlobalFunction(asmodule, dbtype, dbtype.namespace, dbtype.name);
            method.returnType = dbtype.name;
            method.documentation = dbtype.documentation;
            method.isConstructor = true;
            method.args = [
                new typedb.DBArg().init("UObject", "Object", "nullptr"),
                new typedb.DBArg().init("FName", "FunctionName", "NAME_None"),
            ];
        }
    }

    return dbtype;
}
